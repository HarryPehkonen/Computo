# Computo Documentation Source
# This TOML file is the single source of truth for README.md and examples/
# Use: python generate_readme.py && python generate_examples.py

[meta]
title = "Computo"
subtitle = "A safe, sandboxed JSON transformation engine with Lisp-like syntax expressed in JSON"
human_docs_url = "https://harrypehkonen.github.io/ComputoPermutoBook/"
human_docs_repo = "https://github.com/HarryPehkonen/ComputoPermutoBook"

[intro]
description = """
Features RFC 6902 JSON Patch support for document diffing and patching, plus **Permuto** integration for advanced templating.

**ðŸ“– Human-readable documentation:** [Computo & Permuto Book]({human_docs_url}) | [Repository]({human_docs_repo})

*This README is optimized for AI assistants. For tutorials, examples, and learning materials, see the book above.*

## Architecture Overview

- **Computo**: Handles complex programmatic logic (conditionals, loops, calculations, diff/patch operations)
- **Permuto**: Handles simple declarative substitutions and templating using `${{path}}` syntax
- **JSON Patch**: RFC 6902 compliant diff generation and patch application
- **Code is Data**: All scripts are valid JSON with unambiguous syntax
- **Immutable**: Pure functions that don't modify input data
- **Sandboxed**: No I/O operations or system access
- **Enhanced Error Reporting**: Precise path tracking for debugging complex scripts

## Installation & Building

### Prerequisites
- C++17 compatible compiler (GCC 7+, Clang 5+, MSVC 2017+)
- CMake 3.10 or higher
- nlohmann/json library
- Permuto library (included as submodule)

### Building from Source
```bash
# Clone the repository
git clone https://github.com/your-org/computo.git
cd computo

# Initialize submodules
git submodule init
git submodule update

# Configure build
cmake -B build -DCMAKE_BUILD_TYPE=Debug

# Build library and CLI
cmake --build build

# Run tests (198 tests, 100% passing)
cd build && ctest --verbose
```

### Installation
```bash
# Install system-wide
sudo cmake --install build

# Or install to custom prefix
cmake --install build --prefix=/usr/local
```

## Library Usage

### C++ API

Include the header and use the execute function:

```cpp
#include <computo/computo.hpp>

// Single input (traditional)
nlohmann::json script = R"(["*", ["get", ["$input"], "/value"], 2])"_json;
nlohmann::json input = R"({{"value": 21}})"_json;
nlohmann::json result = computo::execute(script, input);
// Result: 42

// Multiple inputs (new)
std::vector<nlohmann::json> inputs = {{
    R"({{"data": [1, 2, 3]}})"_json,
    R"({{"multiplier": 10}})"_json
}};
nlohmann::json multi_script = R"(["map", ["get", ["$inputs"], "/0/data"], 
  ["lambda", ["x"], ["*", ["$", "/x"], ["get", ["$inputs"], "/1/multiplier"]]]])"_json;
nlohmann::json result = computo::execute(multi_script, inputs);
// Result: [10, 20, 30]
```

### Exception Handling
```cpp
try {{
    nlohmann::json result = computo::execute(script, input);
    std::cout << result.dump(2) << std::endl;
}} catch (const computo::ComputoException& e) {{
    std::cerr << "Computo error: " << e.what() << std::endl;
}}
```

### CMake Integration
```cmake
find_package(computo REQUIRED)
target_link_libraries(your_target computo::computo)
```

## Core Syntax

### Operator Calls vs Literal Data
- **Operator call**: `[operator, arg1, arg2, ...]`
- **Literal array**: `{{"array": [item1, item2, ...]}}`
- **Objects**: Standard JSON objects

### System Variables
- `["$input"]` - Access entire input data (first input if multiple)
- `["$inputs"]` - Access all input documents as array
- `["$", "/variable_name"]` - Access variable by path

### Unambiguous Syntax
The key insight of Computo is that **code is data** - all scripts are valid JSON with zero ambiguity between operator calls and literal data.

## CLI Usage

### Basic Usage
```bash
# Single input transformation
./build/computo script.json input.json

# Multiple input processing  
./build/computo script.json input1.json input2.json input3.json

# No input (script only)
./build/computo script.json
```

### Diff Mode
```bash
# Generate patch from transformation
./build/computo --diff transform_script.json original.json
```

### Permuto Integration
```bash
# Enable string interpolation
./build/computo --interpolation script.json input.json
```

### Output Formatting
```bash
# Pretty print with indentation
./build/computo --pretty=2 script.json input.json
```

### Comment Support (CLI Only)
```bash
# Allow comments in script files
./build/computo --comments script_with_comments.json input.json
```
"""

# ============================================================================
# MATHEMATICAL OPERATORS
# ============================================================================

[[examples]]
name = "basic_addition"
category = "arithmetic"
description = """
Basic addition of two numbers.
Computo supports standard arithmetic operations on numbers.
"""
script = ["+", 15, 27]
input = {}
expected = 42

[[examples]]
name = "basic_subtraction"
category = "arithmetic"
description = """
Basic subtraction operation.
Demonstrates numeric subtraction with integer operands.
"""
script = ["-", 50, 8]
input = {}
expected = 42

[[examples]]
name = "basic_multiplication"
category = "arithmetic"
description = """
Basic multiplication of two numbers.
This is the simplest form of Computo operation.
"""
script = ["*", 6, 7]
input = {}
expected = 42

[[examples]]
name = "basic_division"
category = "arithmetic"
description = """
Basic division operation.
Demonstrates numeric division with precise results.
"""
script = ["/", 84, 2]
input = {}
expected = 42

[[examples]]
name = "nested_arithmetic"
category = "arithmetic"
description = """
Nested arithmetic operations showing operator composition.
Demonstrates how operators can be nested to create complex expressions.
"""
script = ["+", ["*", 3, 4], ["*", 5, 6]]
input = {}
expected = 42

[[examples]]
name = "basic_modulo"
category = "arithmetic"
description = """
Basic modulo operation for remainder calculation.
Demonstrates integer remainder operation using the % operator.
"""
script = ["%", 17, 5]
input = {}
expected = 2

[[examples]]
name = "modulo_even_odd_check"
category = "arithmetic"
description = """
Modulo operation for checking even/odd numbers.
Shows practical use of modulo for determining if a number is even.
"""
script = ["%", 42, 2]
input = {}
expected = 0

# ============================================================================
# COMPARISON OPERATORS
# ============================================================================

[[examples]]
name = "greater_than_true"
category = "comparison"
description = """
Greater than comparison returning true.
Demonstrates numeric comparison operations.
"""
script = [">", 10, 5]
input = {}
expected = true

[[examples]]
name = "greater_than_false"
category = "comparison"
description = """
Greater than comparison returning false.
Shows how comparison operators work with different outcomes.
"""
script = [">", 3, 8]
input = {}
expected = false

[[examples]]
name = "less_than_true"
category = "comparison"
description = """
Less than comparison returning true.
Demonstrates the less than operator.
"""
script = ["<", 5, 10]
input = {}
expected = true

[[examples]]
name = "greater_equal_true"
category = "comparison"
description = """
Greater than or equal comparison with equality.
Shows boundary condition handling.
"""
script = [">=", 5, 5]
input = {}
expected = true

[[examples]]
name = "less_equal_false"
category = "comparison"
description = """
Less than or equal comparison returning false.
Demonstrates boundary condition failure.
"""
script = ["<=", 10, 5]
input = {}
expected = false

[[examples]]
name = "equality_strings_true"
category = "comparison"
description = """
String equality comparison returning true.
Demonstrates exact string matching.
"""
script = ["==", "hello", "hello"]
input = {}
expected = true

[[examples]]
name = "equality_strings_false"
category = "comparison"
description = """
String equality comparison returning false.
Shows string inequality detection.
"""
script = ["==", "hello", "world"]
input = {}
expected = false

[[examples]]
name = "not_equal_numbers"
category = "comparison"
description = """
Not equal comparison with numbers.
Demonstrates inequality operator with numeric values.
"""
script = ["!=", 1, 2]
input = {}
expected = true

[[examples]]
name = "approximate_equality"
category = "comparison"
description = """
Approximate equality for floating point numbers.
Uses epsilon tolerance for float comparison to handle precision issues.
"""
script = ["approx", 0.1, 0.10000001, 0.001]
input = {}
expected = true

# ============================================================================
# LOGICAL OPERATORS
# ============================================================================

[[examples]]
name = "logical_and_all_true"
category = "logical"
description = """
Logical AND with all true conditions.
Demonstrates short-circuit evaluation - all expressions must be true.
"""
script = ["&&", true, [">", 10, 5], ["==", 2, 2]]
input = {}
expected = true

[[examples]]
name = "logical_and_short_circuit"
category = "logical"
description = """
Logical AND with short-circuit evaluation.
Shows how AND stops at first false condition, preventing division by zero.
"""
script = ["&&", false, ["/", 1, 0]]
input = {}
expected = false

[[examples]]
name = "logical_or_first_true"
category = "logical"
description = """
Logical OR with short-circuit evaluation.
Demonstrates that OR returns true when first condition is true.
"""
script = ["||", true, ["/", 1, 0]]
input = {}
expected = true

[[examples]]
name = "logical_or_second_true"
category = "logical"
description = """
Logical OR with second condition true.
Shows OR continuing evaluation until it finds a true condition.
"""
script = ["||", false, ["==", 3, 3], ["!=", 1, 1]]
input = {}
expected = true

[[examples]]
name = "logical_or_all_false"
category = "logical"
description = """
Logical OR with all false conditions.
Shows OR behavior when all conditions are false.
"""
script = ["||", false, [">", 2, 5], ["==", "a", "b"]]
input = {}
expected = false

[[examples]]
name = "logical_not_true"
category = "logical"
description = """
Logical NOT operator with true input.
Demonstrates boolean negation returning false for true input.
"""
script = ["not", true]
input = {}
expected = false

[[examples]]
name = "logical_not_false"
category = "logical"
description = """
Logical NOT operator with false input.
Shows boolean negation returning true for false input.
"""
script = ["not", false]
input = {}
expected = true

[[examples]]
name = "logical_not_complex_condition"
category = "logical"
description = """
Logical NOT with complex boolean expression.
Demonstrates negating the result of a comparison operation.
"""
script = ["not", [">", 5, 10]]
input = {}
expected = true

[[examples]]
name = "logical_not_with_string"
category = "logical"
description = """
Logical NOT with non-empty string.
Shows that non-empty strings are truthy, so NOT returns false.
"""
script = ["not", "hello"]
input = {}
expected = false

[[examples]]
name = "logical_not_with_zero"
category = "logical"
description = """
Logical NOT with zero value.
Demonstrates that zero is falsy, so NOT returns true.
"""
script = ["not", 0]
input = {}
expected = true

[[examples]]
name = "logical_not_with_array"
category = "logical"
description = """
Logical NOT with non-empty array.
Shows that non-empty arrays are truthy, so NOT returns false.
"""
script = ["not", {array = [1, 2]}]
input = {}
expected = false

# ============================================================================
# CONDITIONAL EXECUTION
# ============================================================================

[[examples]]
name = "if_condition_true"
category = "conditional"
description = """
Conditional execution with true condition.
Demonstrates basic if-then-else control flow executing the then branch.
"""
script = ["if", [">", 10, 5], "condition_was_true", "condition_was_false"]
input = {}
expected = "condition_was_true"

[[examples]]
name = "if_condition_false"
category = "conditional"
description = """
Conditional execution with false condition.
Shows else branch execution when condition is false.
"""
script = ["if", ["<", 10, 5], "condition_was_true", "condition_was_false"]
input = {}
expected = "condition_was_false"

[[examples]]
name = "if_nested_conditions"
category = "conditional"
description = """
Nested conditional expressions.
Demonstrates how if statements can be nested for complex decision logic.
"""
script = ["if", [">", 15, 10], ["if", ["<", 15, 20], "both_conditions_true", "only_first_true"], "first_condition_false"]
input = {}
expected = "both_conditions_true"

[[examples]]
name = "if_with_complex_condition"
category = "conditional"
description = """
Conditional with complex logical expression.
Shows combining logical operators in if conditions.
"""
script = ["if", ["&&", [">", 20, 10], ["<", 20, 30]], "in_range", "out_of_range"]
input = {}
expected = "in_range"

# ============================================================================
# DATA ACCESS AND INPUT HANDLING
# ============================================================================

[[examples]]
name = "input_access_whole"
category = "data-access"
description = """
Access entire input document.
Demonstrates using $input to access the complete input data.
"""
script = ["$input"]
input = {message = "Hello World", number = 42}
expected = {message = "Hello World", number = 42}

[[examples]]
name = "json_pointer_simple"
category = "data-access"
description = """
Simple JSON Pointer data extraction.
Shows extracting a specific field using JSON Pointer syntax.
"""
script = ["get", ["$input"], "/message"]
input = {message = "Hello Computo", status = "active"}
expected = "Hello Computo"

[[examples]]
name = "json_pointer_nested"
category = "data-access"
description = """
Nested JSON Pointer access.
Demonstrates accessing deeply nested data structures.
"""
script = ["get", ["$input"], "/user/profile/name"]
input = {user = {profile = {name = "Alice", age = 30}, id = 123}}
expected = "Alice"

[[examples]]
name = "json_pointer_array_index"
category = "data-access"
description = """
JSON Pointer array element access.
Shows accessing specific array elements by index.
"""
script = ["get", ["$input"], "/items/1"]
input = {items = ["first", "second", "third"]}
expected = "second"

[[examples]]
name = "variable_binding_simple"
category = "data-access"
description = """
Simple variable binding with let.
Demonstrates creating local variables for reuse in expressions.
"""
script = ["let", [["x", 25], ["y", 17]], ["+", ["$", "/x"], ["$", "/y"]]]
input = {}
expected = 42

[[examples]]
name = "variable_binding_from_input"
category = "data-access"
description = """
Variable binding using input data.
Shows extracting input values into variables for cleaner expressions.
"""
script = ["let", [["user_name", ["get", ["$input"], "/user/name"]], ["user_age", ["get", ["$input"], "/user/age"]]], ["obj", ["greeting", ["$", "/user_name"]], ["next_age", ["+", ["$", "/user_age"], 1]]]]
input = {user = {name = "Bob", age = 25}}
expected = {greeting = "Bob", next_age = 26}

[[examples]]
name = "variable_binding_nested"
category = "data-access"
description = """
Nested variable bindings.
Demonstrates creating multiple variable scopes with let expressions.
"""
script = ["let", [["outer", 10]], ["let", [["inner", 32]], ["+", ["$", "/outer"], ["$", "/inner"]]]]
input = {}
expected = 42

# ============================================================================
# MULTIPLE INPUT HANDLING
# ============================================================================

[[examples]]
name = "multiple_inputs_access_all"
category = "multiple-inputs"
description = """
Access all input documents using $inputs.
Demonstrates the new system variable for multiple input handling.
"""
script = ["$inputs"]
inputs = [
    {type = "user", name = "Alice"},
    {type = "config", theme = "dark"},
    {type = "metadata", version = "1.0"}
]
expected = [
    {type = "user", name = "Alice"},
    {type = "config", theme = "dark"},
    {type = "metadata", version = "1.0"}
]

[[examples]]
name = "multiple_inputs_by_index"
category = "multiple-inputs"
description = """
Access specific inputs by index.
Shows extracting individual documents from multiple inputs.
"""
script = ["obj", ["first_name", ["get", ["$inputs"], "/0/name"]], ["second_name", ["get", ["$inputs"], "/1/name"]]]
inputs = [
    {name = "Alice", role = "admin"},
    {name = "Bob", role = "user"}
]
expected = {first_name = "Alice", second_name = "Bob"}

[[examples]]
name = "multi_input_merge"
category = "multiple-inputs"
description = """
Merge data from multiple inputs using $inputs.
Shows how to access different input files and combine them.
"""
script = ["obj", ["user", ["get", ["$inputs"], "/0"]], ["config", ["get", ["$inputs"], "/1"]]]
inputs = [
    {name = "Alice", id = 123},
    {theme = "dark", lang = "en"}
]
expected = {user = {name = "Alice", id = 123}, config = {theme = "dark", lang = "en"}}

[[examples]]
name = "input_count"
category = "multiple-inputs"
description = """
Count the number of input documents.
Demonstrates using count operator with the $inputs array.
"""
script = ["count", ["$inputs"]]
inputs = [
    {data = "first"},
    {data = "second"},
    {data = "third"}
]
expected = 3

[[examples]]
name = "backward_compatibility"
category = "multiple-inputs"
description = """
Backward compatibility - $input equals first input.
Shows that existing scripts still work with multiple inputs.
"""
script = ["obj", ["old_way", ["$input"]], ["new_way", ["get", ["$inputs"], "/0"]]]  
inputs = [
    {message = "Hello World"}
]
expected = {old_way = {message = "Hello World"}, new_way = {message = "Hello World"}}

# ============================================================================
# DATA CONSTRUCTION
# ============================================================================

[[examples]]
name = "object_construction_simple"
category = "data-construction"
description = """
Simple object construction using obj operator.
Shows creating JSON objects with literal values.
"""
script = ["obj", ["name", "Alice"], ["age", 30], ["active", true]]
input = {}
expected = {name = "Alice", age = 30, active = true}

[[examples]]
name = "object_construction_computed"
category = "data-construction"
description = """
Object construction with computed values.
Demonstrates creating objects with calculated fields.
"""
script = ["obj", ["name", "Bob"], ["birth_year", ["-", 2024, 25]], ["score", ["*", 6, 7]]]
input = {}
expected = {name = "Bob", birth_year = 1999, score = 42}

[[examples]]
name = "array_construction_literal"
category = "data-construction"
description = """
Array construction using literal syntax.
Shows creating arrays with the {"array": [...]} syntax.
"""
script = {array = [1, 2, 3, "hello", true]}
input = {}
expected = [1, 2, 3, "hello", true]

[[examples]]
name = "array_construction_mixed"
category = "data-construction"
description = """
Array construction with mixed literal and computed values.
Demonstrates arrays containing both static and calculated elements.
"""
script = {array = [1, ["*", 2, 3], ["+", 4, 3], "mixed"]}
input = {}
expected = [1, 6, 7, "mixed"]

[[examples]]
name = "nested_object_construction"
category = "data-construction"
description = """
Nested object and array construction.
Shows creating complex nested data structures.
"""
script = ["obj", ["user", ["obj", ["name", "Charlie"], ["hobbies", {array = ["reading", "coding"]}]]], ["metadata", ["obj", ["created", "2024-01-01"], ["version", 1]]]]
input = {}
expected = {user = {name = "Charlie", hobbies = ["reading", "coding"]}, metadata = {created = "2024-01-01", version = 1}}

[[examples]]
name = "object_from_input_data"
category = "data-construction"
description = """
Dynamic object construction from input data.
Demonstrates building objects using values extracted from input.
"""
script = ["obj", ["full_name", ["get", ["$input"], "/first_name"]], ["age_category", ["if", [">", ["get", ["$input"], "/age"], 18], "adult", "minor"]]]
input = {first_name = "Diana", age = 25}
expected = {full_name = "Diana", age_category = "adult"}

# ============================================================================
# ARRAY OPERATIONS
# ============================================================================

[[examples]]
name = "array_map_double"
category = "array-operations"
description = """
Array transformation using map to double values.
Demonstrates applying a function to each array element.
"""
script = ["map", {array = [1, 2, 3, 4]}, ["lambda", ["x"], ["*", ["$", "/x"], 2]]]
input = {}
expected = [2, 4, 6, 8]

[[examples]]
name = "array_map_from_input"
category = "array-operations"
description = """
Map operation on array from input data.
Shows transforming arrays that come from input documents.
"""
script = ["map", ["get", ["$input"], "/numbers"], ["lambda", ["n"], ["+", ["$", "/n"], 10]]]
input = {numbers = [1, 2, 3]}
expected = [11, 12, 13]

[[examples]]
name = "array_filter_greater_than"
category = "array-operations"
description = """
Array filtering based on numeric condition.
Shows keeping only elements that satisfy a predicate.
"""
script = ["filter", {array = [1, 2, 3, 4, 5, 6]}, ["lambda", ["x"], [">", ["$", "/x"], 3]]]
input = {}
expected = [4, 5, 6]

[[examples]]
name = "array_filter_greater_than_two"
category = "array-operations"
description = """
Filter array to keep numbers greater than 2.
Demonstrates filtering arrays based on numeric conditions.
"""
script = ["filter", {array = [1, 2, 3, 4, 5, 6, 7, 8]}, ["lambda", ["x"], [">", ["$", "/x"], 2]]]
input = {}
expected = [3, 4, 5, 6, 7, 8]

[[examples]]
name = "array_reduce_sum"
category = "array-operations"
description = """
Array reduction to sum all elements.
Demonstrates aggregating an array to a single value.
"""
script = ["reduce", {array = [1, 2, 3, 4, 5]}, ["lambda", ["acc", "x"], ["+", ["$", "/acc"], ["$", "/x"]]], 0]
input = {}
expected = 15

[[examples]]
name = "array_reduce_product"
category = "array-operations"
description = """
Array reduction to multiply all elements.
Shows calculating the product using reduce with different initial value.
"""
script = ["reduce", {array = [2, 3, 4]}, ["lambda", ["acc", "x"], ["*", ["$", "/acc"], ["$", "/x"]]], 1]
input = {}
expected = 24

[[examples]]
name = "array_find_first_match"
category = "array-operations"
description = """
Find first element matching condition.
Shows locating the first element that satisfies a predicate.
"""
script = ["find", {array = [1, 2, 5, 8, 10]}, ["lambda", ["x"], [">", ["$", "/x"], 4]]]
input = {}
expected = 5

[[examples]]
name = "array_some_has_match"
category = "array-operations"
description = """
Test if some elements match condition.
Demonstrates checking if any element satisfies a condition.
"""
script = ["some", {array = [1, 2, 3, 8]}, ["lambda", ["x"], [">", ["$", "/x"], 5]]]
input = {}
expected = true

[[examples]]
name = "array_some_no_match"
category = "array-operations"
description = """
Test if some elements match condition - no matches.
Shows some operator returning false when no elements match.
"""
script = ["some", {array = [1, 2, 3, 4]}, ["lambda", ["x"], [">", ["$", "/x"], 10]]]
input = {}
expected = false

[[examples]]
name = "array_every_all_match"
category = "array-operations"
description = """
Test if all elements match condition - all match.
Shows every operator returning true when all elements satisfy condition.
"""
script = ["every", {array = [4, 6, 8, 10]}, ["lambda", ["x"], [">", ["$", "/x"], 3]]]
input = {}
expected = true

[[examples]]
name = "array_every_not_all"
category = "array-operations"
description = """
Test if all elements match condition - not all match.
Demonstrates every operator returning false when some elements don't match.
"""
script = ["every", {array = [2, 4, 6, 8]}, ["lambda", ["x"], [">", ["$", "/x"], 3]]]
input = {}
expected = false

[[examples]]
name = "array_flatmap_expand"
category = "array-operations"
description = """
Map and flatten array results.
Demonstrates mapping over an array and flattening nested results.
"""
script = ["flatMap", {array = [1, 2, 3]}, ["lambda", ["x"], {array = [["$", "/x"], ["*", ["$", "/x"], 2]]}]]
input = {}
expected = [1, 2, 2, 4, 3, 6]

[[examples]]
name = "array_partition_by_size"
category = "array-operations"
description = """
Partition array into large and small numbers.
Shows splitting an array based on a predicate into [matching, non-matching].
"""
script = ["partition", {array = [1, 2, 3, 4, 5, 6]}, ["lambda", ["x"], [">", ["$", "/x"], 3]]]
input = {}
expected = [[4, 5, 6], [1, 2, 3]]

[[examples]]
name = "array_count_length"
category = "array-operations"
description = """
Get array length using count.
Demonstrates measuring the size of arrays.
"""
script = ["count", {array = ["apple", "banana", "cherry", "date"]}]
input = {}
expected = 4

[[examples]]
name = "array_zip_combine_pairs"
category = "array-operations"
description = """
Zip two arrays into element pairs.
Demonstrates combining corresponding elements from two arrays into pairs.
"""
script = ["zip", {array = ["a", "b", "c"]}, {array = [1, 2, 3]}]
input = {}
expected = [["a", 1], ["b", 2], ["c", 3]]

[[examples]]
name = "array_zip_different_lengths"
category = "array-operations"
description = """
Zip arrays of different lengths.
Shows that zip stops at the shorter array's length.
"""
script = ["zip", {array = [1, 2, 3, 4, 5]}, {array = ["x", "y"]}]
input = {}
expected = [[1, "x"], [2, "y"]]

[[examples]]
name = "array_zipWith_custom_combination"
category = "array-operations"
description = """
Zip two arrays with custom combination function.
Demonstrates combining arrays element-wise using a lambda function.
"""
script = ["zipWith", {array = [1, 2, 3]}, {array = [10, 20, 30]}, ["lambda", ["a", "b"], ["+", ["$", "/a"], ["$", "/b"]]]]
input = {}
expected = [11, 22, 33]

[[examples]]
name = "array_zipWith_string_formatting"
category = "array-operations"
description = """
ZipWith for string formatting and concatenation.
Shows practical use of zipWith for combining data from parallel arrays.
"""
script = ["zipWith", {array = ["Alice", "Bob", "Charlie"]}, {array = [25, 30, 35]}, ["lambda", ["name", "age"], ["str_concat", ["$", "/name"], " is ", ["$", "/age"], " years old"]]]
input = {}
expected = ["Alice is 25 years old", "Bob is 30 years old", "Charlie is 35 years old"]

[[examples]]
name = "array_mapWithIndex_element_position"
category = "array-operations"
description = """
Map over array with element indices.
Demonstrates accessing both element value and position during transformation.
"""
script = ["mapWithIndex", {array = ["apple", "banana", "cherry"]}, ["lambda", ["item", "index"], ["obj", ["position", ["$", "/index"]], ["fruit", ["$", "/item"]]]]]
input = {}
expected = [{position = 0, fruit = "apple"}, {position = 1, fruit = "banana"}, {position = 2, fruit = "cherry"}]

[[examples]]
name = "array_mapWithIndex_conditional_processing"
category = "array-operations"
description = """
Map with index for conditional processing based on position.
Shows using index information to apply different logic to even/odd positions.
"""
script = ["mapWithIndex", {array = [10, 20, 30, 40]}, ["lambda", ["value", "index"], ["if", ["==", ["%", ["$", "/index"], 2], 0], ["*", ["$", "/value"], 2], ["$", "/value"]]]]
input = {}
expected = [20, 20, 60, 40]

[[examples]]
name = "array_enumerate_index_value_pairs"
category = "array-operations"
description = """
Convert array to [index, value] pairs.
Demonstrates creating enumerated pairs for processing with indices.
"""
script = ["enumerate", {array = ["red", "green", "blue"]}]
input = {}
expected = [[0, "red"], [1, "green"], [2, "blue"]]

[[examples]]
name = "array_enumerate_for_processing"
category = "array-operations"
description = """
Use enumerate for indexed processing.
Shows practical use of enumerate to create numbered lists or process with position awareness.
"""
script = ["map", ["enumerate", {array = ["Task A", "Task B", "Task C"]}], ["lambda", ["pair"], ["str_concat", ["get", ["$", "/pair"], "/0"], ". ", ["get", ["$", "/pair"], "/1"]]]]
input = {}
expected = ["0. Task A", "1. Task B", "2. Task C"]

# ============================================================================
# FUNCTIONAL LIST OPERATIONS
# ============================================================================

[[examples]]
name = "list_car_first_element"
category = "functional-lists"
description = """
Get first element using car.
Demonstrates the car operation from functional programming.
"""
script = ["car", {array = ["first", "second", "third"]}]
input = {}
expected = "first"

[[examples]]
name = "list_car_single_element"
category = "functional-lists"
description = """
Car operation on single-element array.
Shows car behavior with minimal arrays.
"""
script = ["car", {array = [42]}]
input = {}
expected = 42

[[examples]]
name = "list_cdr_rest_elements"
category = "functional-lists"
description = """
Get all but first element using cdr.
Shows the cdr operation for accessing the tail of a list.
"""
script = ["cdr", {array = [1, 2, 3, 4, 5]}]
input = {}
expected = [2, 3, 4, 5]

[[examples]]
name = "list_cdr_single_element"
category = "functional-lists"
description = """
Cdr operation on single-element array.
Shows cdr returning empty array for single-element lists.
"""
script = ["cdr", {array = ["only"]}]
input = {}
expected = []

[[examples]]
name = "list_cons_prepend"
category = "functional-lists"
description = """
Prepend element using cons.
Demonstrates list construction by adding element to front.
"""
script = ["cons", "new_first", {array = ["second", "third"]}]
input = {}
expected = ["new_first", "second", "third"]

[[examples]]
name = "list_cons_empty_array"
category = "functional-lists"
description = """
Cons operation with empty array.
Shows creating single-element array using cons.
"""
script = ["cons", "only_element", {array = []}]
input = {}
expected = ["only_element"]

[[examples]]
name = "list_append_two_arrays"
category = "functional-lists"
description = """
Concatenate two arrays using append.
Shows basic array concatenation functionality.
"""
script = ["append", {array = [1, 2]}, {array = [3, 4]}]
input = {}
expected = [1, 2, 3, 4]

[[examples]]
name = "list_append_multiple_arrays"
category = "functional-lists"
description = """
Concatenate multiple arrays using append.
Demonstrates joining several arrays together.
"""
script = ["append", {array = ["a"]}, {array = ["b", "c"]}, {array = ["d", "e", "f"]}]
input = {}
expected = ["a", "b", "c", "d", "e", "f"]

[[examples]]
name = "list_chunk_even_split"
category = "functional-lists"
description = """
Split array into even chunks.
Shows breaking an array into equal-sized smaller arrays.
"""
script = ["chunk", {array = [1, 2, 3, 4, 5, 6]}, 2]
input = {}
expected = [[1, 2], [3, 4], [5, 6]]

[[examples]]
name = "list_chunk_uneven_split"
category = "functional-lists"
description = """
Split array into chunks with remainder.
Demonstrates chunking when array size isn't divisible by chunk size.
"""
script = ["chunk", {array = [1, 2, 3, 4, 5, 6, 7]}, 3]
input = {}
expected = [[1, 2, 3], [4, 5, 6], [7]]

[[examples]]
name = "list_car_cdr_composition"
category = "functional-lists"
description = """
Compose car and cdr to get second element.
Shows how functional operations can be composed for complex access.
"""
script = ["car", ["cdr", {array = ["first", "second", "third", "fourth"]}]]
input = {}
expected = "second"

[[examples]]
name = "list_functional_pipeline"
category = "functional-lists"
description = """
Complex functional composition pipeline.
Demonstrates chaining multiple functional operations together.
"""
script = ["cons", "new_head", ["cdr", ["cdr", {array = ["remove1", "remove2", "keep1", "keep2"]}]]]
input = {}
expected = ["new_head", "keep1", "keep2"]

# ============================================================================
# LAMBDA FUNCTIONS
# ============================================================================

[[examples]]
name = "lambda_simple_transform"
category = "lambda-functions"
description = """
Simple lambda function for array transformation.
Demonstrates basic lambda syntax with single parameter.
"""
script = ["map", {array = [1, 2, 3, 4]}, ["lambda", ["x"], ["+", ["$", "/x"], 100]]]
input = {}
expected = [101, 102, 103, 104]

[[examples]]
name = "lambda_conditional_logic"
category = "lambda-functions"
description = """
Lambda with conditional logic.
Shows lambda functions containing if-then-else expressions.
"""
script = ["map", {array = [1, 5, 10, 15]}, ["lambda", ["x"], ["if", [">", ["$", "/x"], 5], ["*", ["$", "/x"], 2], ["$", "/x"]]]]
input = {}
expected = [1, 5, 20, 30]

[[examples]]
name = "lambda_multiple_parameters"
category = "lambda-functions"
description = """
Lambda with multiple parameters in reduce.
Demonstrates lambda functions with accumulator and item parameters for string concatenation.
"""
script = ["reduce", {array = ["Hello", "World", "From", "Computo"]}, ["lambda", ["acc", "word"], ["str_concat", ["$", "/acc"], ["$", "/word"]]], ""]
input = {}
expected = "HelloWorldFromComputo"

[[examples]]
name = "lambda_nested_operations"
category = "lambda-functions"
description = """
Lambda with nested arithmetic operations.
Shows complex expressions within lambda bodies.
"""
script = ["map", {array = [1, 2, 3, 4]}, ["lambda", ["x"], ["+", ["*", ["$", "/x"], ["$", "/x"]], ["*", 2, ["$", "/x"]]]]]
input = {}
expected = [3, 8, 15, 24]

[[examples]]
name = "lambda_variables_for_reuse"
category = "lambda-functions"
description = """
Reusable lambda functions stored in variables.
Demonstrates storing lambda functions in let variables for reuse.
"""
script = ["let", [["doubler", ["lambda", ["x"], ["*", ["$", "/x"], 2]]]], ["obj", ["first_list", ["map", {array = [1, 2, 3]}, ["$", "/doubler"]]], ["second_list", ["map", {array = [10, 20, 30]}, ["$", "/doubler"]]]]]
input = {}
expected = {first_list = [2, 4, 6], second_list = [20, 40, 60]}

[[examples]]
name = "lambda_multiple_reusable_functions"
category = "lambda-functions"
description = """
Multiple lambda variables for different operations.
Shows storing and reusing multiple lambda functions.
"""
script = ["let", [["add_ten", ["lambda", ["x"], ["+", ["$", "/x"], 10]]], ["gt_three", ["lambda", ["x"], [">", ["$", "/x"], 3]]]], ["map", ["filter", {array = [1, 2, 3, 4, 5, 6]}, ["$", "/gt_three"]], ["$", "/add_ten"]]]
input = {}
expected = [14, 15, 16]

[[examples]]
name = "lambda_closure_behavior"
category = "lambda-functions"
description = """
Lambda function accessing outer scope variables.
Demonstrates variable capture in lambda expressions.
"""
script = ["let", [["multiplier", 3]], ["map", {array = [1, 2, 3, 4]}, ["lambda", ["x"], ["*", ["$", "/x"], ["$", "/multiplier"]]]]]
input = {}
expected = [3, 6, 9, 12]

# ============================================================================
# JSON PATCH OPERATIONS (RFC 6902)
# ============================================================================

[[examples]]
name = "json_patch_diff_replace"
category = "json-patch"
description = """
Generate JSON Patch diff with replace operation.
Demonstrates creating RFC 6902 compliant patches for field changes.
"""
script = ["diff", {name = "Alice", status = "active"}, {name = "Alice", status = "inactive"}]
input = {}
expected = [{op = "replace", path = "/status", value = "inactive"}]

[[examples]]
name = "json_patch_diff_add_field"
category = "json-patch"
description = """
Generate JSON Patch diff with add operation.
Shows patch generation when new fields are added.
"""
script = ["diff", {name = "Bob"}, {name = "Bob", age = 30}]
input = {}
expected = [{op = "add", path = "/age", value = 30}]

[[examples]]
name = "json_patch_diff_remove_field"
category = "json-patch"
description = """
Generate JSON Patch diff with remove operation.
Demonstrates patch creation when fields are deleted.
"""
script = ["diff", {name = "Charlie", temp = "remove_me"}, {name = "Charlie"}]
input = {}
expected = [{op = "remove", path = "/temp"}]

[[examples]]
name = "json_patch_apply_replace"
category = "json-patch"
description = """
Apply JSON Patch replace operation.
Shows applying RFC 6902 patches to modify documents.
"""
script = ["patch", {name = "David", status = "pending"}, {array = [{op = "replace", path = "/status", value = "completed"}]}]
input = {}
expected = {name = "David", status = "completed"}

[[examples]]
name = "json_patch_apply_add"
category = "json-patch"
description = """
Apply JSON Patch add operation.
Demonstrates adding new fields to documents via patches.
"""
script = ["patch", {name = "Eve"}, {array = [{op = "add", path = "/role", value = "admin"}]}]
input = {}
expected = {name = "Eve", role = "admin"}

[[examples]]
name = "json_patch_apply_remove"
category = "json-patch"
description = """
Apply JSON Patch remove operation.
Shows removing fields from documents using patches.
"""
script = ["patch", {name = "Frank", temp_field = "delete_this", role = "user"}, {array = [{op = "remove", path = "/temp_field"}]}]
input = {}
expected = {name = "Frank", role = "user"}

[[examples]]
name = "json_patch_apply_move"
category = "json-patch"
description = """
Apply JSON Patch move operation.
Demonstrates moving fields within documents.
"""
script = ["patch", {user_name = "Grace", profile = {}}, {array = [{op = "move", from = "/user_name", path = "/profile/name"}]}]
input = {}
expected = {profile = {name = "Grace"}}

[[examples]]
name = "json_patch_apply_copy"
category = "json-patch"
description = """
Apply JSON Patch copy operation.
Shows copying values to new locations in documents.
"""
script = ["patch", {id = 12345, data = {important = "value"}}, {array = [{op = "copy", from = "/data/important", path = "/backup_value"}]}]
input = {}
expected = {id = 12345, data = {important = "value"}, backup_value = "value"}

[[examples]]
name = "json_patch_apply_test_success"
category = "json-patch"
description = """
Apply JSON Patch with successful test operation.
Demonstrates conditional patching using test operations.
"""
script = ["patch", {version = 1, data = "current"}, {array = [{op = "test", path = "/version", value = 1}, {op = "replace", path = "/data", value = "updated"}]}]
input = {}
expected = {version = 1, data = "updated"}

[[examples]]
name = "json_patch_multiple_operations"
category = "json-patch"
description = """
Apply multiple JSON Patch operations in sequence.
Shows complex document transformations with multiple patch operations.
"""
script = ["patch", {name = "Henry", status = "draft", temp = "remove"}, {array = [{op = "replace", path = "/status", value = "published"}, {op = "remove", path = "/temp"}, {op = "add", path = "/published_date", value = "2024-01-01"}]}]
input = {}
expected = {name = "Henry", status = "published", published_date = "2024-01-01"}

# ============================================================================
# PERMUTO INTEGRATION
# ============================================================================

[[examples]]
name = "permuto_simple_interpolation"
category = "permuto"
description = """
Simple Permuto template with string interpolation.
Demonstrates basic variable substitution in strings.
"""
script = ["permuto.apply", {greeting = "Hello ${/name}!", role = "User: ${/role}"}, {name = "Alice", role = "Administrator"}]
input = {}
expected = {greeting = "Hello Alice!", role = "User: Administrator"}
flags = ["--interpolation"]

[[examples]]
name = "permuto_with_input_data"
category = "permuto"
description = """
Permuto template using input data as context.
Shows using input document as the template context.
"""
script = ["permuto.apply", {summary = "Profile: ${/profile/name} (${/profile/email})", status = "Active: ${/active}"}, ["$input"]]
input = {profile = {name = "Bob", email = "bob@example.com"}, active = true}
expected = {summary = "Profile: Bob (bob@example.com)", status = "Active: true"}
flags = ["--interpolation"]

[[examples]]
name = "permuto_nested_object_access"
category = "permuto"
description = """
Permuto templates with deep object access.
Demonstrates accessing nested data in template interpolation.
"""
script = ["permuto.apply", {message = "User ${/user/profile/firstName} ${/user/profile/lastName} has ${/user/stats/points} points"}, {user = {profile = {firstName = "Charlie", lastName = "Brown"}, stats = {points = 1500}}}]
input = {}
expected = {message = "User Charlie Brown has 1500 points"}
flags = ["--interpolation"]

[[examples]]
name = "permuto_array_access"
category = "permuto"
description = """
Permuto templates accessing array elements.
Shows using array indices in template paths.
"""
script = ["permuto.apply", {first_item = "First: ${/items/0}", last_item = "Last: ${/items/2}"}, {items = ["apple", "banana", "cherry"]}]
input = {}
expected = {first_item = "First: apple", last_item = "Last: cherry"}
flags = ["--interpolation"]

[[examples]]
name = "permuto_computed_context"
category = "permuto"
description = """
Permuto with computed template context.
Demonstrates building template context using Computo operations.
"""
script = ["permuto.apply", {report = "Total: ${/sum}, Average: ${/avg}"}, ["obj", ["sum", ["reduce", {array = [10, 20, 30]}, ["lambda", ["a", "b"], ["+", ["$", "/a"], ["$", "/b"]]], 0]], ["avg", ["/", 60, 3]]]]
input = {}
expected = {report = "Total: 60, Average: 20.000000"}
flags = ["--interpolation"]

# ============================================================================
# REAL-WORLD EXAMPLES
# ============================================================================

[[examples]]
name = "api_response_transform"
category = "real-world"
description = """
Transform API response structure.
Demonstrates typical API data transformation patterns in real applications.
"""
script = ["obj", ["users", ["map", ["get", ["$input"], "/data"], ["lambda", ["user"], ["obj", ["id", ["get", ["$", "/user"], "/userId"]], ["name", ["get", ["$", "/user"], "/fullName"]], ["active", ["==", ["get", ["$", "/user"], "/status"], "active"]]]]]], ["metadata", ["obj", ["total", ["count", ["get", ["$input"], "/data"]]], ["processed_at", "2024-01-01"]]]]
input = {data = [{userId = 1, fullName = "Alice Smith", status = "active"}, {userId = 2, fullName = "Bob Jones", status = "inactive"}]}
expected = {users = [{id = 1, name = "Alice Smith", active = true}, {id = 2, name = "Bob Jones", active = false}], metadata = {total = 2, processed_at = "2024-01-01"}}

[[examples]]
name = "configuration_merge_multiple_sources"
category = "real-world"
description = """
Merge configuration from multiple input sources.
Shows practical configuration management with precedence rules.
"""
script = ["let", [["defaults", ["get", ["$inputs"], "/0"]], ["environment", ["get", ["$inputs"], "/1"]], ["user_prefs", ["get", ["$inputs"], "/2"]]], ["obj", ["database", ["obj", ["host", ["get", ["$", "/user_prefs"], "/database/host"]], ["port", ["get", ["$", "/defaults"], "/database/port"]], ["ssl", ["get", ["$", "/environment"], "/database/ssl"]]]], ["logging", ["get", ["$", "/environment"], "/logging"]], ["theme", ["get", ["$", "/user_prefs"], "/ui/theme"]]]]
inputs = [
    {database = {host = "localhost", port = 5432}, logging = {level = "info"}},
    {database = {ssl = true}, logging = {level = "debug"}},
    {database = {host = "prod.example.com"}, ui = {theme = "dark"}}
]
expected = {database = {host = "prod.example.com", port = 5432, ssl = true}, logging = {level = "debug"}, theme = "dark"}

[[examples]]
name = "document_versioning_workflow"
category = "real-world"
description = """
Document versioning with patch generation and rollback capability.
Demonstrates creating version control for documents with change tracking.
"""
script = ["let", [["original", ["get", ["$inputs"], "/0"]], ["modified", ["get", ["$inputs"], "/1"]], ["changes", ["diff", ["$", "/original"], ["$", "/modified"]]], ["rollback_patch", ["diff", ["$", "/modified"], ["$", "/original"]]]], ["obj", ["document_id", ["get", ["$", "/original"], "/id"]], ["version_info", ["obj", ["from_version", ["get", ["$", "/original"], "/version"]], ["to_version", ["get", ["$", "/modified"], "/version"]], ["change_count", ["count", ["$", "/changes"]]]]], ["forward_patch", ["$", "/changes"]], ["rollback_patch", ["$", "/rollback_patch"]], ["can_rollback", [">", ["count", ["$", "/rollback_patch"]], 0]]]]
inputs = [
    {id = "doc_001", version = 1, title = "Original Title", content = "Original content"},
    {id = "doc_001", version = 2, title = "Updated Title", content = "Updated content", author = "Alice"}
]
expected = {document_id = "doc_001", version_info = {from_version = 1, to_version = 2, change_count = 4}, forward_patch = [{op = "replace", path = "/content", value = "Updated content"}, {op = "replace", path = "/title", value = "Updated Title"}, {op = "replace", path = "/version", value = 2}, {op = "add", path = "/author", value = "Alice"}], rollback_patch = [{op = "remove", path = "/author"}, {op = "replace", path = "/content", value = "Original content"}, {op = "replace", path = "/title", value = "Original Title"}, {op = "replace", path = "/version", value = 1}], can_rollback = true}

[[examples]]
name = "functional_pipeline_multi_input"
category = "real-world"
description = """
Functional pipeline processing using car/cdr for multiple inputs.
Shows advanced functional programming patterns for processing input sequences.
"""
script = ["let", [["initial_doc", ["car", ["$inputs"]]], ["patch_sequence", ["cdr", ["$inputs"]]], ["final_doc", ["reduce", ["$", "/patch_sequence"], ["lambda", ["doc", "patch"], ["patch", ["$", "/doc"], ["$", "/patch"]]], ["$", "/initial_doc"]]]], ["obj", ["initial_state", ["$", "/initial_doc"]], ["final_state", ["$", "/final_doc"]], ["transformations_applied", ["count", ["$", "/patch_sequence"]]], ["title_changed", ["!=", ["get", ["$", "/initial_doc"], "/title"], ["get", ["$", "/final_doc"], "/title"]]]]]
inputs = [
    {id = "doc_123", title = "Draft", status = "draft", content = "Initial content"},
    [{op = "replace", path = "/status", value = "review"}],
    [{op = "replace", path = "/title", value = "Final Document"}],
    [{op = "add", path = "/reviewed_by", value = "Editor"}],
    [{op = "replace", path = "/status", value = "published"}]
]
expected = {initial_state = {id = "doc_123", title = "Draft", status = "draft", content = "Initial content"}, final_state = {id = "doc_123", title = "Final Document", status = "published", content = "Initial content", reviewed_by = "Editor"}, transformations_applied = 4, title_changed = true}

[[examples]]
name = "data_aggregation_report"
category = "real-world"
description = """
Data aggregation and reporting pipeline.
Demonstrates complex data processing for analytics and reporting.
"""
script = ["let", [["sales_data", ["get", ["$input"], "/sales"]], ["total_revenue", ["reduce", ["$", "/sales_data"], ["lambda", ["sum", "sale"], ["+", ["$", "/sum"], ["get", ["$", "/sale"], "/amount"]]], 0]], ["high_value_sales", ["filter", ["$", "/sales_data"], ["lambda", ["sale"], [">", ["get", ["$", "/sale"], "/amount"], 1000]]]], ["north_sales", ["filter", ["$", "/sales_data"], ["lambda", ["sale"], ["==", ["get", ["$", "/sale"], "/region"], "North"]]]], ["north_total", ["reduce", ["$", "/north_sales"], ["lambda", ["sum", "sale"], ["+", ["$", "/sum"], ["get", ["$", "/sale"], "/amount"]]], 0]]], ["obj", ["summary", ["obj", ["total_sales", ["count", ["$", "/sales_data"]]], ["total_revenue", ["$", "/total_revenue"]], ["average_sale", ["/", ["$", "/total_revenue"], ["count", ["$", "/sales_data"]]]]]], ["high_value", ["obj", ["count", ["count", ["$", "/high_value_sales"]]], ["revenue", ["reduce", ["$", "/high_value_sales"], ["lambda", ["sum", "sale"], ["+", ["$", "/sum"], ["get", ["$", "/sale"], "/amount"]]], 0]]]], ["north_region", ["obj", ["sales_count", ["count", ["$", "/north_sales"]]], ["total_revenue", ["$", "/north_total"]]]]]]
input = {sales = [{region = "North", amount = 1500, product = "A"}, {region = "South", amount = 800, product = "B"}, {region = "North", amount = 2000, product = "C"}, {region = "East", amount = 1200, product = "A"}]}
expected = {summary = {total_sales = 4, total_revenue = 5500, average_sale = 1375}, high_value = {count = 3, revenue = 4700}, north_region = {sales_count = 2, total_revenue = 3500}}

# ============================================================================
# CLI USAGE EXAMPLES (Documentation)
# ============================================================================

[[examples]]
name = "cli_basic_transformation"
category = "cli-usage"
description = """
Basic CLI usage for single input transformation.
This demonstrates the standard command-line interface pattern.
Note: This is a documentation example showing CLI usage patterns.
"""
script = ["obj", ["greeting", ["get", ["$input"], "/message"]], ["timestamp", "2024-01-01"]]
input = {message = "Hello from CLI", user = "Alice"}
expected = {greeting = "Hello from CLI", timestamp = "2024-01-01"}
cli_example = "./build/computo script.json input.json"

[[examples]]
name = "cli_multiple_inputs_merge"
category = "cli-usage"
description = """
CLI usage with multiple input files for data merging.
Shows processing multiple input files from the command line.
Note: This is a documentation example showing multi-input CLI patterns.
"""
script = ["obj", ["combined_data", ["append", ["get", ["$inputs"], "/0/items"], ["get", ["$inputs"], "/1/items"]]], ["sources", ["count", ["$inputs"]]]]
inputs = [
    {items = ["from_file_1", "data_1"]},
    {items = ["from_file_2", "data_2"]}
]
expected = {combined_data = ["from_file_1", "data_1", "from_file_2", "data_2"], sources = 2}
cli_example = "./build/computo script.json input1.json input2.json"

[[examples]]
name = "diff_generation_example"
category = "json-patch"
description = """
Generate JSON Patch between transformed and original documents.
Demonstrates diff generation for document transformation.
"""
script = ["diff", {id = 123, status = "pending", created = "2023-12-01"}, ["obj", ["id", 123], ["status", "completed"], ["created", "2023-12-01"], ["completed_date", "2024-01-01"]]]
input = {}
expected = [{op = "replace", path = "/status", value = "completed"}, {op = "add", path = "/completed_date", value = "2024-01-01"}]

[[examples]]
name = "cli_permuto_interpolation"
category = "cli-usage"
description = """
CLI with Permuto interpolation for template processing.
Shows using --interpolation flag for string template processing.
Note: This is a documentation example showing Permuto integration.
"""
script = ["permuto.apply", {welcome = "Welcome ${/user/name}!", summary = "You have ${/user/points} points."}, ["$input"]]
input = {user = {name = "Bob", points = 250}}
expected = {welcome = "Welcome Bob!", summary = "You have 250 points."}
cli_example = "./build/computo --interpolation script.json input.json"
flags = ["--interpolation"]

[[examples]]
name = "cli_pretty_output_formatting"
category = "cli-usage"
description = """
CLI with pretty-printed output formatting.
Demonstrates using --pretty flag for readable JSON output.
Note: This is a documentation example showing output formatting.
"""
script = ["obj", ["data", ["map", {array = [1, 2, 3]}, ["lambda", ["x"], ["obj", ["value", ["$", "/x"]], ["squared", ["*", ["$", "/x"], ["$", "/x"]]]]]]], ["timestamp", "2024-01-01"]]
input = {}
expected = {data = [{value = 1, squared = 1}, {value = 2, squared = 4}, {value = 3, squared = 9}], timestamp = "2024-01-01"}
cli_example = "./build/computo --pretty=2 script.json input.json"

[[examples]]
name = "cli_comments_in_scripts"
category = "cli-usage"
description = """
CLI with comment support in script files.
Shows using --comments flag to allow comments in JSON scripts.
Note: This is a documentation example showing comment parsing.
"""
script = ["obj", ["message", "Hello World"], ["computed", ["*", 6, 7]]]
input = {}
expected = {message = "Hello World", computed = 42}
cli_example = "./build/computo --comments script_with_comments.json input.json"

# ============================================================================
# COMPUTO BUILDER PATTERN (C++ API)
# ============================================================================

[[examples]]
name = "builder_basic_vs_manual"
category = "cpp-builder"
description = """
ComputoBuilder vs manual JSON construction comparison.
Shows how the builder pattern eliminates verbose JSON syntax in C++ tests.
Note: This is C++ API documentation - builder creates the JSON shown in 'script'.
"""
script = ["+", 15, 27]
input = {}
expected = 42
cpp_example = """
// Manual JSON (old way)
json manual = json::array({"+", 15, 27});

// ComputoBuilder (new way)  
auto builder = CB::add(15, 27);

// Both produce the same JSON script shown above
EXPECT_EQ(computo::execute(builder, input), 42);
"""

[[examples]]
name = "builder_array_construction"
category = "cpp-builder"
description = """
Builder pattern for array construction.
Demonstrates how builder eliminates the painful array wrapper syntax.
Note: CB::array creates the JSON array structure shown in 'script'.
"""
script = {array = [1, 2, 3, 4, 5]}
input = {}
expected = [1, 2, 3, 4, 5]
cpp_example = """
// Manual JSON (painful)
json manual = json{{"array", json::array({1, 2, 3, 4, 5})}};

// ComputoBuilder (clean)
auto builder = CB::array({1, 2, 3, 4, 5});

// Much more readable and type-safe!
"""

[[examples]]
name = "builder_complex_nesting"
category = "cpp-builder"
description = """
Builder pattern for complex nested operations.
Shows how builder makes deeply nested expressions readable and maintainable.
Note: This C++ builder code produces the JSON script shown.
"""
script = ["map", {array = [1, 2, 3, 4]}, ["lambda", ["x"], ["+", ["$", "/x"], 10]]]
input = {}
expected = [11, 12, 13, 14]
cpp_example = """
// Manual JSON (unreadable)
json manual = json::array({
    "map",
    json{{"array", json::array({1, 2, 3, 4})}},
    json::array({"lambda", json::array({"x"}), 
                json::array({"+", json::array({"$", "/x"}), 10})})
});

// ComputoBuilder (self-documenting)
auto builder = CB::map(
    CB::array({1, 2, 3, 4}),
    CB::lambda("x", CB::add(CB::var("x"), 10))
);
"""

[[examples]]
name = "builder_object_construction"
category = "cpp-builder"
description = """
Fluent object construction with builder pattern.
Demonstrates chaining methods for building complex objects.
Note: Shows C++ fluent API that generates the JSON object structure.
"""
script = ["obj", ["name", "Alice"], ["age", 30], ["score", ["+", 85, 15]]]
input = {}
expected = {name = "Alice", age = 30, score = 100}
cpp_example = """
// ComputoBuilder fluent object construction
auto builder = CB::obj()
    .add_field("name", "Alice")
    .add_field("age", 30)
    .add_field("score", CB::add(85, 15));

// Type-safe and IDE-friendly with autocomplete
"""

[[examples]]
name = "builder_variables_and_let"
category = "cpp-builder"
description = """
Variable binding with builder pattern.
Shows clean syntax for let expressions and variable references.
Note: Builder provides type-safe variable handling in C++.
"""
script = ["let", [["multiplier", 3], ["base", 14]], ["+", ["*", ["$", "/base"], ["$", "/multiplier"]], ["$", "/base"]]]
input = {}
expected = 56
cpp_example = """
// Manual JSON (error-prone)
json manual = json::array({
    "let",
    json::array({json::array({"multiplier", 3}), json::array({"base", 14})}),
    json::array({"+", 
        json::array({"*", json::array({"$", "/base"}), json::array({"$", "/multiplier"})}),
        json::array({"$", "/base"})})
});

// ComputoBuilder (clean and safe)
auto builder = CB::let({
    {"multiplier", 3},
    {"base", 14}
}, CB::add(
    CB::multiply(CB::var("base"), CB::var("multiplier")),
    CB::var("base")
));
"""

[[examples]]
name = "builder_conditional_logic"
category = "cpp-builder"
description = """
Conditional expressions with builder pattern.
Demonstrates readable if-then-else construction in C++.
Note: Builder methods provide compile-time safety for conditional logic.
"""
script = ["if", [">", ["get", ["$input"], "/value"], 50], "high", "low"]
input = {value = 75}
expected = "high"
cpp_example = """
// ComputoBuilder conditional logic
auto builder = CB::if_(
    CB::greater_than(CB::get(CB::input(), "/value"), 50),
    "high",
    "low"
);

// Note: CB::if_() avoids C++ 'if' keyword conflict
"""

[[examples]]
name = "builder_data_access_patterns"
category = "cpp-builder"
description = """
Data access patterns with builder.
Shows input access, JSON pointer usage, and data extraction.
Note: Type-safe data access with compile-time path validation.
"""
script = ["obj", ["user", ["get", ["$input"], "/user/name"]], ["processed", true]]
input = {user = {name = "Bob", email = "bob@test.com"}}
expected = {user = "Bob", processed = true}
cpp_example = """
// ComputoBuilder data access
auto builder = CB::obj()
    .add_field("user", CB::get(CB::input(), "/user/name"))
    .add_field("processed", true);

// JSON Pointer paths are validated and autocompleted
"""

[[examples]]
name = "builder_functional_operations"
category = "cpp-builder"
description = """
Functional array operations with builder.
Demonstrates map, filter, and reduce operations with readable syntax.
Note: Builder makes functional programming patterns accessible in C++.
"""
script = ["map", ["filter", {array = [1, 2, 3, 4, 5, 6]}, ["lambda", ["x"], [">", ["$", "/x"], 3]]], ["lambda", ["x"], ["*", ["$", "/x"], 2]]]
input = {}
expected = [8, 10, 12]
cpp_example = """
// ComputoBuilder functional pipeline
auto builder = CB::map(
    CB::filter(
        CB::array({1, 2, 3, 4, 5, 6}),
        CB::lambda("x", CB::greater_than(CB::var("x"), 3))
    ),
    CB::lambda("x", CB::multiply(CB::var("x"), 2))
);

// Readable functional programming pipeline
"""

[[examples]]
name = "builder_generic_operators"
category = "cpp-builder"
description = """
Generic operator construction with builder.
Shows fallback syntax for any operator using the generic builder pattern.
Note: Provides escape hatch for operators without dedicated builder methods.
"""
script = ["reduce", {array = [1, 2, 3, 4]}, ["lambda", ["acc", "x"], ["+", ["$", "/acc"], ["$", "/x"]]], 0]
input = {}
expected = 10
cpp_example = """
// Generic operator when no specific method exists
auto builder = CB::op("reduce")
    .arg(CB::array({1, 2, 3, 4}))
    .arg(CB::lambda({"acc", "x"}, CB::add(CB::var("acc"), CB::var("x"))))
    .arg(0);

// Fluent chaining also works:
auto alt = CB::op("reduce") 
    << CB::array({1, 2, 3, 4})
    << CB::lambda({"acc", "x"}, CB::add(CB::var("acc"), CB::var("x")))
    << 0;
"""

[[examples]]
name = "builder_type_safety_benefits"
category = "cpp-builder"
description = """
Type safety and IDE benefits of builder pattern.
Demonstrates compile-time error checking and development experience improvements.
Note: Builder prevents common JSON construction errors at compile time.
"""
script = ["*", 6, 7]
input = {}
expected = 42
cpp_example = """
// Type safety examples

// âœ… GOOD: Type-safe builder
auto correct = CB::multiply(6, 7);

// âŒ BAD: Manual JSON prone to errors
// json error1 = json::array({"*", 6, 7, 8});  // Wrong arity
// json error2 = json::array({"multiply", 6, 7}); // Wrong operator name  
// json error3 = json({"+", 6, 7});  // Missing array wrapper

// Builder provides:
// - Compile-time arity checking
// - IDE autocomplete for operators
// - Automatic JSON structure generation
// - Template argument deduction
"""

# ============================================================================
# ENHANCED DEBUGGING SUPPORT
# ============================================================================

[[examples]]
name = "debug_basic_tracing"
category = "debugging"
description = """
Basic debugging with execution tracing enabled.
Shows how to enable execution tracing to see operation flow.
Note: This demonstrates CLI debugging flags - actual trace output goes to stderr.
"""
script = ["obj", ["result", ["+", ["*", 3, 4], ["*", 5, 6]]], ["computed", true]]
input = {}
expected = {result = 42, computed = true}
cli_example = "./build/computo --debug --trace script.json input.json"

[[examples]]
name = "debug_performance_profiling"
category = "debugging"
description = """
Performance profiling to identify slow operations.
Demonstrates using profiling to measure execution times and identify bottlenecks.
Note: Performance reports are sent to stderr, JSON result to stdout.
"""
script = ["reduce", {array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, ["lambda", ["acc", "x"], ["+", ["$", "/acc"], ["*", ["$", "/x"], ["$", "/x"]]]], 0]
input = {}
expected = 385
cli_example = "./build/computo --debug --profile script.json input.json"

[[examples]]
name = "debug_slow_operation_detection"
category = "debugging"
description = """
Detect and report operations slower than threshold.
Shows using slow operation detection to find performance issues.
Note: Operations slower than 5ms will be flagged in the debug output.
"""
script = ["map", {array = [1, 2, 3, 4, 5]}, ["lambda", ["x"], ["reduce", {array = [1, 2, 3, 4, 5]}, ["lambda", ["a", "b"], ["+", ["$", "/a"], ["*", ["$", "/b"], ["$", "/x"]]]], 0]]]
input = {}
expected = [15, 30, 45, 60, 75]
cli_example = "./build/computo --debug --profile --slow-threshold=5 script.json input.json"

[[examples]]
name = "debug_operator_breakpoints"
category = "debugging"
description = """
Set breakpoints on specific operators for debugging.
Demonstrates halting execution when specific operators are encountered.
Note: In non-interactive mode, breakpoints log to stderr without stopping.
"""
script = ["let", [["data", {array = [1, 2, 3, 4, 5]}]], ["map", ["$", "/data"], ["lambda", ["x"], ["*", ["$", "/x"], 2]]]]
input = {}
expected = [2, 4, 6, 8, 10]
cli_example = "./build/computo --debug --trace --break-on=map script.json input.json"

[[examples]]
name = "debug_variable_watching"
category = "debugging"
description = """
Watch variable changes during execution.
Shows tracking specific variables and their value changes throughout execution.
Note: Variable watch output appears in the execution trace on stderr.
"""
script = ["let", [["multiplier", 3], ["base", 14]], ["+", ["*", ["$", "/base"], ["$", "/multiplier"]], ["$", "/base"]]]
input = {}
expected = 56
cli_example = "./build/computo --debug --trace --watch=multiplier --watch=base script.json input.json"

[[examples]]
name = "debug_comprehensive_analysis"
category = "debugging"
description = """
Comprehensive debugging with all features enabled.
Demonstrates using multiple debugging features together for complete analysis.
Note: Combines tracing, profiling, breakpoints, and variable watching.
"""
script = ["let", [["numbers", {array = [10, 20, 30]}]], ["reduce", ["$", "/numbers"], ["lambda", ["sum", "num"], ["+", ["$", "/sum"], ["*", ["$", "/num"], 2]]], 0]]
input = {}
expected = 120
cli_example = "./build/computo --debug --trace --profile --watch=numbers --break-on=reduce --slow-threshold=1 script.json input.json"

[[examples]]
name = "debug_error_diagnosis"
category = "debugging"
description = """
Enhanced error reporting with debugging enabled.
Shows how debugging provides detailed error context and execution history.
Note: This example would normally cause an error, shown here for documentation.
"""
script = ["obj", ["safe_result", ["+", 20, 22]], ["info", "This part works fine"]]
input = {}
expected = {safe_result = 42, info = "This part works fine"}
cli_example = "./build/computo --debug --trace --debug-level=verbose script.json input.json"

[[examples]]
name = "debug_log_levels"
category = "debugging"
description = """
Different debug log levels for varying detail amounts.
Demonstrates controlling the verbosity of debug output.
Note: Higher levels (verbose) provide more detailed execution information.
"""
script = ["map", {array = ["hello", "world", "debug"]}, ["lambda", ["str"], ["str_concat", ["$", "/str"], "!"]]]
input = {}
expected = ["hello!", "world!", "debug!"]
cli_example = "./build/computo --debug --trace --debug-level=verbose script.json input.json"

[[examples]]
name = "debug_complex_operations"
category = "debugging"
description = """
Debugging complex nested operations and data transformations.
Shows debugging sophisticated scripts with multiple operators and deep nesting.
Note: Trace output shows the complete execution flow through nested operations.
"""
script = ["let", [["users", {array = [{name = "Alice", score = 85}, {name = "Bob", score = 92}, {name = "Charlie", score = 78}]}]], ["obj", ["top_scorer", ["car", ["filter", ["$", "/users"], ["lambda", ["user"], [">", ["get", ["$", "/user"], "/score"], 90]]]]], ["average_score", ["/", ["reduce", ["map", ["$", "/users"], ["lambda", ["user"], ["get", ["$", "/user"], "/score"]]], ["lambda", ["sum", "score"], ["+", ["$", "/sum"], ["$", "/score"]]], 0], ["count", ["$", "/users"]]]]]]
input = {}
expected = {top_scorer = {name = "Bob", score = 92}, average_score = 85}
cli_example = "./build/computo --debug --trace --profile --watch=users --break-on=filter script.json input.json"

[[examples]]
name = "debug_interactive_session"
category = "debugging"
description = """
Interactive debugging for step-through execution.
Demonstrates interactive debugging mode for manual script inspection.
Note: Interactive mode allows step-by-step execution with variable inspection.
"""
script = ["let", [["step1", 15], ["step2", 27]], ["+", ["$", "/step1"], ["$", "/step2"]]]
input = {}
expected = 42
cli_example = "./build/computo --debug --interactive --break-on=+ script.json input.json"

# ============================================================================
# DEBUGGING REFERENCE & TROUBLESHOOTING
# ============================================================================

[[examples]]
name = "debug_levels_reference"
category = "debugging"
description = """
Complete reference for debug levels and their output detail.
Each level includes all output from lower levels (error < warning < info < debug < verbose).
Use higher levels for more detailed information when troubleshooting complex issues.
"""
script = ["obj", ["result", ["+", 20, 22]], ["computed", true]]
input = {}
expected = {result = 42, computed = true}
debug_levels = """
ðŸ” DEBUG LEVELS EXPLAINED:

â€¢ error: Only critical errors, exceptions, and fatal issues
  - Script parsing errors
  - Runtime exceptions
  - Missing file errors

â€¢ warning: Errors + performance warnings and deprecated usage
  - Slow operations without --slow-threshold
  - Deprecated operator usage
  - Potential optimization opportunities

â€¢ info: Warnings + basic execution flow and timing summary
  - Total execution time
  - High-level operation flow
  - Success/failure status

â€¢ debug: Info + detailed operation parameters and intermediate results
  - Individual operator execution
  - Variable assignments
  - Data structure details

â€¢ verbose: Debug + full variable state, memory usage, and internal details
  - Complete execution trace
  - Memory allocation patterns
  - Internal state changes
  - JSON pointer resolution details
"""
cli_example = "./build/computo --debug --debug-level=verbose script.json input.json"

[[examples]]
name = "debug_output_channels_guide"
category = "debugging"
description = """
Understanding where debug output goes and how to capture it.
Critical for scripting, automation, and saving debug information for analysis.
Explains stderr vs stdout separation and redirection techniques.
"""
script = ["obj", ["message", "Hello Debug"], ["value", 42]]
input = {}
expected = {message = "Hello Debug", value = 42}
output_guide = """
ðŸ“¤ OUTPUT CHANNELS:

â€¢ stdout (standard output): JSON results only
  - Final script result
  - Clean JSON for piping to other tools
  - No debug noise mixed in

â€¢ stderr (standard error): All debug information
  - Execution traces
  - Performance profiles
  - Error messages
  - Debugging tips

ðŸ”§ CAPTURE TECHNIQUES:

# Save JSON result only
./build/computo --debug --trace script.json input.json > result.json

# Save debug info only  
./build/computo --debug --trace script.json input.json 2> debug.log

# Save both separately
./build/computo --debug --trace script.json input.json > result.json 2> debug.log

# Save everything together
./build/computo --debug --trace script.json input.json > combined.log 2>&1

# Silent JSON output with debug visible
./build/computo --debug --trace script.json input.json > /dev/null
"""
cli_example = "./build/computo --debug --trace script.json input.json 2> debug.log"

[[examples]]
name = "debug_output_samples"
category = "debugging"
description = """
Sample debug output showing what users should expect to see.
Demonstrates the actual format and content of debug information.
Helps users understand and interpret debugging output effectively.
"""
script = ["obj", ["result", ["+", ["*", 3, 4], 18]], ["computed", true]]
input = {}
expected = {result = 30, computed = true}
sample_output = """
ðŸ” ACTUAL DEBUG OUTPUT SAMPLES:

â–¶ WITH --debug --trace:
ðŸ” Debug mode enabled [TRACE]

ðŸ“‹ EXECUTION TRACE:
===================
[0.15ms] evaluate: ["obj", ["result", ["+", ["*", 3, 4], 18]], ["computed", true]]
[0.08ms] obj: Creating object with 2 fields
[0.03ms] *: 3 * 4 = 12
[0.02ms] +: 12 + 18 = 30
[0.02ms] obj: {"result": 30, "computed": true}

âœ… EXECUTION SUCCESSFUL in 0.30ms
==========================================

ðŸ“¤ RESULT:
==========

â–¶ WITH --debug --profile:
â±ï¸  PERFORMANCE PROFILE:
========================
Total execution: 0.30ms
Operation breakdown:
- obj (0.10ms, 33%): Object construction
- + (0.02ms, 7%): Addition operation  
- * (0.03ms, 10%): Multiplication operation
- evaluate (0.15ms, 50%): Script evaluation overhead

Memory usage: 2.1KB peak
Operations executed: 4

â–¶ WITH --debug --debug-level=verbose:
[VERBOSE] JSON pointer resolution: /result -> field access
[VERBOSE] Variable scope created: {}
[VERBOSE] Memory allocated: 1.2KB for intermediate results
[DEBUG] Operator '*': args=[3, 4], type=number+number
[INFO] Operation completed: 12
"""
cli_example = "./build/computo --debug --trace --profile script.json input.json"

[[examples]]
name = "debugging_workflow_systematic"
category = "debugging"
description = """
Systematic debugging workflow for troubleshooting Computo scripts.
Step-by-step methodology for diagnosing different types of issues.
Provides a structured approach from simple to complex debugging techniques.
"""
script = ["map", {array = [1, 2, 3]}, ["lambda", ["x"], ["*", ["$", "/x"], 2]]]
input = {}
expected = [2, 4, 6]
workflow = """
ðŸ”¬ SYSTEMATIC DEBUGGING WORKFLOW:

1ï¸âƒ£ BASIC EXECUTION TEST
   ./build/computo script.json input.json
   â†’ Verify script runs without syntax errors

2ï¸âƒ£ ADD EXECUTION TRACING  
   ./build/computo --debug --trace script.json input.json
   â†’ See operation flow and identify where issues occur

3ï¸âƒ£ ADD PERFORMANCE PROFILING
   ./build/computo --debug --trace --profile script.json input.json  
   â†’ Identify slow operations and bottlenecks

4ï¸âƒ£ FOCUS ON PROBLEM AREAS
   ./build/computo --debug --trace --break-on=OPERATOR script.json input.json
   â†’ Stop at specific operations that might be causing issues

5ï¸âƒ£ WATCH VARIABLE CHANGES
   ./build/computo --debug --trace --watch=VARIABLE script.json input.json
   â†’ Track how specific variables change through execution

6ï¸âƒ£ INCREASE VERBOSITY
   ./build/computo --debug --trace --debug-level=verbose script.json input.json
   â†’ Get maximum detail when other methods don't reveal the issue

7ï¸âƒ£ SAVE AND ANALYZE
   ./build/computo --debug --trace --profile script.json input.json 2> analysis.log
   â†’ Save detailed logs for deeper investigation

ðŸŽ¯ ISSUE-SPECIFIC STRATEGIES:

â€¢ Wrong Results: Use --trace to see execution flow
â€¢ Performance Issues: Use --profile and --slow-threshold=N  
â€¢ Variable Problems: Use --watch=VARIABLE_NAME
â€¢ Complex Scripts: Use --break-on=OPERATOR for step-by-step
â€¢ Error Diagnosis: Use --debug-level=verbose for maximum detail
"""
cli_example = "./build/computo --debug --trace --profile script.json input.json"

[[examples]]
name = "performance_optimization_guide"
category = "debugging"
description = """
Advanced performance analysis and optimization techniques.
Shows systematic approach to finding and fixing performance bottlenecks.
Includes specific strategies for different types of performance issues.
"""
script = ["reduce", {array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, ["lambda", ["acc", "x"], ["+", ["$", "/acc"], ["*", ["$", "/x"], ["$", "/x"]]]], 0]
input = {}
expected = 385
optimization_guide = """
âš¡ PERFORMANCE OPTIMIZATION GUIDE:

ðŸ” DETECTION TECHNIQUES:

â€¢ Find slow operations:
  --slow-threshold=1  # Report operations > 1ms
  --slow-threshold=5  # Report operations > 5ms (default threshold)

â€¢ Compare performance versions:
  ./build/computo --debug --profile script.json input.json > v1_profile.txt
  # (make changes)
  ./build/computo --debug --profile script.json input.json > v2_profile.txt
  diff v1_profile.txt v2_profile.txt

â€¢ Profile with different data sizes:
  ./build/computo --debug --profile script.json small_data.json
  ./build/computo --debug --profile script.json large_data.json

ðŸŽ¯ OPTIMIZATION STRATEGIES:

â€¢ Reduce Operations: Often the bottleneck with large arrays
  - Watch for: --watch=accumulator --break-on=reduce
  - Optimize: Minimize operations inside lambda functions

â€¢ Map Operations: Can be expensive with complex transformations
  - Watch for: --break-on=map --slow-threshold=1
  - Optimize: Simplify lambda expressions, avoid nested maps

â€¢ Object Construction: obj operator with many fields
  - Watch for: --break-on=obj
  - Optimize: Group related data, avoid redundant field creation

â€¢ Variable Access: Excessive $"/path" lookups
  - Watch for: --watch=frequently_accessed_var
  - Optimize: Use let bindings to cache expensive lookups

ðŸ“Š INTERPRETING PROFILE OUTPUT:

â€¢ Time Distribution:
  > 50% in one operation â†’ Focus optimization there
  Many small operations â†’ Look for redundant work
  High evaluation overhead â†’ Simplify script structure

â€¢ Memory Patterns:
  Steadily increasing â†’ Potential memory accumulation
  Large spikes â†’ Heavy intermediate data structures
  High peak usage â†’ Consider data streaming approaches

ðŸš€ ADVANCED TECHNIQUES:

â€¢ Benchmark with realistic data:
  ./build/computo --debug --profile --slow-threshold=1 script.json production_data.json

â€¢ Monitor specific variables in loops:
  ./build/computo --debug --trace --watch=loop_counter --watch=accumulator script.json

â€¢ Break on expensive operations:
  ./build/computo --debug --interactive --break-on=reduce --break-on=map script.json
"""
cli_example = "./build/computo --debug --profile --slow-threshold=1 script.json input.json"

[[examples]]
name = "common_debugging_scenarios"
category = "debugging"
description = """
Common debugging scenarios and their solutions.
Real-world troubleshooting examples with specific commands and expected outcomes.
Covers the most frequent issues users encounter with Computo scripts.
"""
script = ["get", ["$input"], "/user/name"]
input = {user = {name = "Alice", email = "alice@test.com"}}
expected = "Alice"
scenarios = """
ðŸ”§ COMMON DEBUGGING SCENARIOS:

1ï¸âƒ£ "Script returns wrong result"
   SYMPTOM: Output doesn't match expectations
   DEBUG: ./build/computo --debug --trace script.json input.json
   LOOK FOR: Each operation's input/output in trace
   SOLUTION: Verify data flow through each step

2ï¸âƒ£ "Script is too slow"  
   SYMPTOM: Takes longer than expected
   DEBUG: ./build/computo --debug --profile --slow-threshold=5 script.json input.json
   LOOK FOR: Operations consuming most time
   SOLUTION: Optimize or replace expensive operations

3ï¸âƒ£ "Variable not found" errors
   SYMPTOM: ComputoException: Variable '/path' not found
   DEBUG: ./build/computo --debug --trace --watch=variable_name script.json input.json
   LOOK FOR: When and where variables are created/accessed
   SOLUTION: Check let bindings and JSON pointer paths

4ï¸âƒ£ "Script works with small data, fails with large data"
   SYMPTOM: Success with test data, errors with production data
   DEBUG: ./build/computo --debug --profile --debug-level=verbose script.json large_data.json
   LOOK FOR: Memory usage spikes, timeout operations
   SOLUTION: Optimize data processing, add error handling

5ï¸âƒ£ "Nested operations are confusing"
   SYMPTOM: Complex script is hard to understand/debug
   DEBUG: ./build/computo --debug --trace --break-on=map --break-on=reduce script.json input.json
   LOOK FOR: Step-by-step execution of nested operations
   SOLUTION: Break complex expressions into let bindings

6ï¸âƒ£ "JSON parsing errors"
   SYMPTOM: "JSON parsing error in script.json"
   DEBUG: python3 -m json.tool script.json  # Validate JSON first
   DEBUG: ./build/computo --comments script.json input.json  # If using comments
   LOOK FOR: Syntax errors, trailing commas, unquoted strings
   SOLUTION: Fix JSON syntax or use --comments flag

7ï¸âƒ£ "Performance regression"
   SYMPTOM: Script was fast, now slow after changes
   DEBUG: 
     git checkout previous_version
     ./build/computo --debug --profile script.json input.json > old_profile.txt
     git checkout current_version  
     ./build/computo --debug --profile script.json input.json > new_profile.txt
     diff old_profile.txt new_profile.txt
   LOOK FOR: Operations that became slower, new expensive operations
   SOLUTION: Revert problematic changes or optimize new code

8ï¸âƒ£ "Interactive debugging for complex issues"
   SYMPTOM: Need to step through execution manually
   DEBUG: ./build/computo --debug --interactive --break-on=problematic_op script.json input.json
   LOOK FOR: Variable state at each breakpoint
   SOLUTION: Inspect state and continue step-by-step

ðŸ’¡ GENERAL DEBUGGING TIPS:

â€¢ Start simple: Test with minimal input data first
â€¢ Save debug output: Always use 2> debug.log for analysis
â€¢ Use version control: Compare profiles before/after changes
â€¢ Test incrementally: Add complexity gradually
â€¢ Validate JSON: Use json.tool before debugging script logic
â€¢ Read error messages: They often point directly to the issue
"""
cli_example = "./build/computo --debug --trace --debug-level=verbose script.json input.json"

[[examples]]
name = "debug_flag_combinations_guide"
category = "debugging"
description = """
Effective combinations of debugging flags for different scenarios.
Shows which flags work well together and when to use specific combinations.
Provides templates for common debugging tasks and workflows.
"""
script = ["let", [["data", {array = [1, 2, 3, 4, 5]}]], ["reduce", ["$", "/data"], ["lambda", ["acc", "x"], ["+", ["$", "/acc"], ["*", ["$", "/x"], 2]]], 0]]
input = {}
expected = 30
flag_combinations = """
ðŸŽ›ï¸ DEBUGGING FLAG COMBINATIONS:

ðŸ” BASIC INVESTIGATION:
   --debug --trace
   â†’ See execution flow with timing
   â†’ Good for: Understanding script behavior

ðŸ” PERFORMANCE ANALYSIS:  
   --debug --profile --slow-threshold=5
   â†’ Focus on operations slower than 5ms
   â†’ Good for: Finding bottlenecks

ðŸ” DETAILED TROUBLESHOOTING:
   --debug --trace --debug-level=verbose
   â†’ Maximum information output
   â†’ Good for: Complex issues requiring deep inspection

ðŸ” VARIABLE TRACKING:
   --debug --trace --watch=variable_name
   â†’ Track specific variable changes
   â†’ Good for: Data flow issues, unexpected values

ðŸ” OPERATION-SPECIFIC DEBUGGING:
   --debug --trace --break-on=map --break-on=reduce
   â†’ Stop at specific operations
   â†’ Good for: Complex nested operations

ðŸ” COMPREHENSIVE ANALYSIS:
   --debug --trace --profile --watch=data --slow-threshold=1
   â†’ Everything enabled for thorough analysis
   â†’ Good for: Persistent issues, optimization work

ðŸ” DEVELOPMENT WORKFLOW:
   --debug --trace --profile --pretty=2
   â†’ Debugging with readable output
   â†’ Good for: Development and testing

ðŸ” PRODUCTION DEBUGGING:
   --debug --debug-level=error
   â†’ Minimal debug output, errors only
   â†’ Good for: Production troubleshooting without noise

ðŸ” INTERACTIVE INSPECTION:
   --debug --interactive --trace --break-on=problematic_op
   â†’ Manual step-through with full control
   â†’ Good for: Complex logic verification

ðŸ” PERFORMANCE COMPARISON:
   --debug --profile
   â†’ Clean performance metrics only
   â†’ Good for: Benchmarking, before/after comparisons

âš ï¸ FLAGS TO AVOID TOGETHER:

â€¢ --interactive with --profile: Interactive mode disrupts timing
â€¢ --debug-level=verbose with large data: Too much output
â€¢ Multiple --break-on with --profile: Breaks disrupt timing measurements

ðŸ’¡ RECOMMENDED WORKFLOWS:

1. Start with: --debug --trace
2. Add profiling: --debug --trace --profile  
3. Focus investigation: --debug --trace --watch=specific_var
4. Deep dive: --debug --trace --debug-level=verbose
5. Performance work: --debug --profile --slow-threshold=N
"""
cli_example = "./build/computo --debug --trace --profile --watch=data --slow-threshold=1 script.json input.json"
